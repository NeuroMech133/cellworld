#!/bin/bash

operator=$1

function help(){
    echo 'usage: worker -c "COMMAND" -w [SIMULTANEOUS WORKERS] [options]'
    echo '  or:  worker --command "WORKER COMMAND" --workers [SIMULTANEOUS WORKERS] [options]'
    echo "Execute a command on a worker limiting the number of simultaneous executions."
    echo ""
    echo "Mandatory arguments to long options are mandatory for short options too."
    echo ' -c, --command "COMMAND"  command executed by the worker'
    echo " -k, --kill               kill all active workers"
    echo " -p, --progress           show active workers progress"
    echo " -s, --status             update own worker progress status"
}

function wait_for_workers(){
    while [ $(ps -at | grep "[w]orker -launch" | wc -l) -ge $1 ]; do
      sleep .01
    done
}

function write_worker_log(){
    worker_PID=$1
    state_date_time=$(date +'%Y-%m-%d %H:%M:%S')
    state=$2
    WORKER_STATE=~/.workers.state.${worker_PID}
    printf "%s: %s\n" "${state_date_time}" "${state}" >> "$WORKER_STATE"
}

function update_status(){
    worker_PID=$1
    state=$2
    if [ "$(ps -at | grep '[w]orker -launch' | grep "$worker_PID" | wc -l)" == 1 ]; then
      write_worker_log $worker_PID "$state"
    fi
}

function kill_workers(){
  while IFS= read -r line
  do
    PID=$(echo "$line" |awk -F" " '{print $1}')
    kill -9 $PID
  done <<< $(ps -at | grep '[w]orker -launch')

}

case $operator in
    -launch)
    COMMAND="$2"
    OUTPUT="$3"
    ERROR="$4"
    if [ "$OUTPUT" == "" ]; then
      OUTPUT="/dev/null"
    fi
    if [ "$ERROR" == "" ]; then
      OUTPUT="/dev/null"
    fi
    write_worker_log $$ "Stated"
    $COMMAND >> "$OUTPUT" 2>> "$ERROR"
    #rm "~/.workers.state.${$}"
    exit
    ;;
    -c)
    WORKERS="$2"
    COMMAND="$3"
    OUTPUT="$4"
    ERROR="$5"
    wait_for_workers "$WORKERS"
    worker -launch "$COMMAND" "$OUTPUT" "$ERROR" &
    exit
    ;;
    -k)
    kill_workers
    exit
    ;;
    -h)
    help
    exit
    ;;
    *)    # unknown option
    echo "unknown option '$operator'"
#    help
    exit
    ;;
esac